<h1>{% if form.instance.pk %}Edit Character{% else %}Create Character{% endif %}</h1>
<button type="submit">{% if form.instance.pk %}Save{% else %}Create{% endif %}</button>
<p><a href="{% url 'characters' %}">Back to list</a></p>
<form method="POST" action="">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">{% if form.instance.pk %}Save{% else %}Create{% endif %}</button>
</form>

<script>
    const classSelect = document.getElementById('id_character_class');
    const subclassSelect = document.getElementById('id_subclass');
    // Znajdujemy akapit lub div, w którym siedzi pole, żeby ukryć je z etykietą
    const subclassContainer = subclassSelect.closest('p') || subclassSelect.parentElement;

    function updateSubclasses() {
    const selectedClass = classSelect.value.toUpperCase(); // Pobiera np. 'ROGUE' lub 'CLERIC'
    const options = subclassSelect.options;
    
    // 1. Decyzja: Czy w ogóle wyświetlić pole Subclass?
    // Dodajemy 'CLERIC' do listy klas, które mają subklasy
    if (selectedClass === 'ROGUE' || selectedClass === 'FIGHTER' || selectedClass === 'CLERIC') {
        subclassContainer.style.display = 'block';
    } else {
        subclassContainer.style.display = 'none';
        subclassSelect.value = 'none';
        return;
    }

    // 2. Filtrowanie opcji wewnątrz listy
    for (let i = 0; i < options.length; i++) {
        const val = options[i].value;

        if (selectedClass === 'ROGUE') {
            const rogueSubs = ['thief', 'assassin', 'trickster', 'none'];
            options[i].style.display = rogueSubs.includes(val) ? 'block' : 'none';
        } 
        else if (selectedClass === 'FIGHTER') {
            const fighterSubs = ['champion', 'battle_master', 'none'];
            options[i].style.display = fighterSubs.includes(val) ? 'block' : 'none';
        }
        // DODAJ TEN FRAGMENT DLA KLERYKA:
        else if (selectedClass === 'CLERIC') {
            const clericSubs = ['life', 'war', 'light', 'none'];
            options[i].style.display = clericSubs.includes(val) ? 'block' : 'none';
        }
    }

    // 3. Reset wyboru, jeśli stara subklasa nie pasuje do nowej klasy
    if (options[subclassSelect.selectedIndex].style.display === 'none') {
        subclassSelect.value = 'none';
    }
}
    // Nasłuchiwanie na zmiany w polu klasy
    classSelect.addEventListener('change', updateSubclasses);
    
    // Uruchomienie funkcji od razu po załadowaniu (żeby działało przy edycji postaci)
    window.addEventListener('load', updateSubclasses);
</script>