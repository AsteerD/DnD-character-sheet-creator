diff --git a/base/data/class_features.json b/base/data/class_features.json
new file mode 100644
index 0000000..cdb8002
--- /dev/null
+++ b/base/data/class_features.json
@@ -0,0 +1,36 @@
+{
+  "Bard": [
+    {
+      "name": "Spellcasting",
+      "description": "You have learned to untangle and reshape the fabric of reality in harmony with your wishes and music. Your spells are part of your vast repertoire, magic that you can tune to different situations.\nCantrips\nYou know two cantrips of your choice from the bard spell list. You learn additional bard cantrips of your choice at higher levels, as shown in the Cantrips Known column of the Bard table.",
+      "unlock_level": 1
+    },
+    {
+      "name": "Bardic Inspiration",
+      "description": "You can inspire others through stirring words or music. To do so, you use a bonus action on your turn to choose one creature other than yourself within 60 feet of you who can hear you. That creature gains one Bardic Inspiration die, a d6.\nOnce within the next 10 minutes, the creature can roll the die and add the number rolled to one ability check, attack roll, or saving throw it makes. The creature can wait until after it rolls the d20 before deciding to use the Bardic Inspiration die, but must decide before the DM says whether the roll succeeds or fails. Once the Bardic Inspiration die is rolled, it is lost. A creature can have only one Bardic Inspiration die at a time.You can use this feature a number of times equal to your Charisma modifier (a minimum of once). You regain any expended uses when you finish a long rest.\nYour Bardic Inspiration die changes when you reach certain levels in this class. The die becomes a d8 at 5th level, a d10 at 10th level, and a d12 at 15th level.",
+      "unlock_level": 1
+    },
+    {
+      "name": "Jack of All Trades",
+      "description": "Starting at 2nd level, you can add half your proficiency bonus, rounded down, to any ability check you make that doesn't already include your proficiency bonus.",
+      "unlock_level": 2
+    },
+    {
+      "name": "Song of Rest",
+      "description": "Beginning at 2nd level, you can use soothing music or oration to help revitalize your wounded allies during a short rest. If you or any friendly creatures who can hear your performance regain hit points at the end of the short rest by spending one or more Hit Dice, each of those creatures regains an extra 1d6 hit points.\nThe extra Hit Points increase when you reach certain levels in this class: to 1d8 at 9th level, to 1d10 at 13th level, and to 1d12 at 17th level.",
+      "unlock_level": 2
+    },
+    {
+      "name": "Magical Inspiration (Optional)",
+      "description": "At 2nd level, if a creature has a Bardic Inspiration die from you and casts a spell that restores hit points or deals damage, the creature can roll that die and choose a target affected by the spell. Add the number rolled as a bonus to the hit points regained or the damage dealt. The Bardic Inspiration die is then lost.",
+      "unlock_level": 2
+    }
+  ],
+  "Fighter": [
+    {
+      "name": "Second Wind",
+      "description": "You have a limited well of stamina.",
+      "unlock_level": 1
+    }
+  ]
+}
diff --git a/base/management/commands/__init__.py b/base/management/commands/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/base/management/commands/populate_class_features.py b/base/management/commands/populate_class_features.py
new file mode 100644
index 0000000..6a396a1
--- /dev/null
+++ b/base/management/commands/populate_class_features.py
@@ -0,0 +1,12 @@
+from django.core.management.base import BaseCommand
+from base.utils.class_features_loader import populate_class_features
+
+
+class Command(BaseCommand):
+    help = "Populate class features from JSON data file"
+
+    def handle(self, *args, **options):
+        populate_class_features()
+        self.stdout.write(
+            self.style.SUCCESS("Class features populated successfully.")
+        )
diff --git a/base/migrations/0015_populate_class_features.py b/base/migrations/0015_populate_class_features.py
new file mode 100644
index 0000000..140beb4
--- /dev/null
+++ b/base/migrations/0015_populate_class_features.py
@@ -0,0 +1,17 @@
+from django.db import migrations
+from base.utils.class_features_loader import populate_class_features
+
+
+def forwards(apps, schema_editor):
+    populate_class_features(apps=apps)
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ("base", "0014_classfeature"),
+    ]
+
+    operations = [
+        migrations.RunPython(forwards),
+    ]
diff --git a/base/utils/class_features_loader.py b/base/utils/class_features_loader.py
new file mode 100644
index 0000000..ef0daee
--- /dev/null
+++ b/base/utils/class_features_loader.py
@@ -0,0 +1,57 @@
+import json
+from pathlib import Path
+from django.apps import apps as global_apps
+
+
+def get_data_path():
+    """
+    Resolves base/data/class_features.json WITHOUT absolute paths.
+    Works in migrations and runtime.
+    """
+    base_app = global_apps.get_app_config("base")
+    return Path(base_app.path) / "data" / "class_features.json"
+
+
+def populate_class_features(apps=None):
+    """
+    If `apps` is provided -> migration-safe (uses historical models)
+    If not -> runtime (uses real models)
+    """
+    if apps:
+        CharacterClass = apps.get_model("base", "CharacterClass")
+        Subclass = apps.get_model("base", "Subclass")
+        ClassFeature = apps.get_model("base", "ClassFeature")
+    else:
+        from base.models import CharacterClass, Subclass, ClassFeature
+
+    data_path = get_data_path()
+
+    if not data_path.exists():
+        raise FileNotFoundError(f"Missing data file: {data_path}")
+
+    with data_path.open(encoding="utf-8") as f:
+        data = json.load(f)
+
+    for class_name, features in data.items():
+        try:
+            char_class = CharacterClass.objects.get(name=class_name)
+        except CharacterClass.DoesNotExist:
+            continue
+
+        for feature in features:
+            subclass = None
+            if "subclass" in feature:
+                subclass = Subclass.objects.filter(
+                    name=feature["subclass"],
+                    character_class=char_class,
+                ).first()
+
+            ClassFeature.objects.get_or_create(
+                character_class=char_class,
+                subclass=subclass,
+                name=feature["name"],
+                defaults={
+                    "description": feature["description"],
+                    "unlock_level": feature["unlock_level"],
+                },
+            )
